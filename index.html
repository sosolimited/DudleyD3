<!DOCTYPE html>
<html>
  <meta charset="utf-8">
  <head>
    <title>DudleyD3 - Sosolimited</title>
    <link rel="stylesheet" type="text/css" href="css/style.css">
  </head>
  <body>
    <div class="wrapper">

      <div id="game_title"><h1>Dudley D3 Dashboard</h1></div>

      <div class="main_container"></div>

    </div>
    
  <script src="js/jquery-1.11.1.min.js"></script>
  <script src="js/d3.min.js"></script>
  <script src="js/common.js"></script>
  <script src="js/OpenLayers.js"></script>  <!-- Used for calculating if a lat/long point is within a geojson polygon, ie. to determine what neighborhood a request made in. -->
  <script type="text/javascript" charset="utf-8">
    
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - General - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    var charts = [];
    var counts = null;            // Stores the count of number of requests per neighborhood. Because it is memory intensive (takes about 6 seconds) we want to do it only once and store as a global var.
    var allRequestTypes;
    
    var charts_data = [ 
                        ["data/dudley-june23-750results-manuallycollated.json", "activity/neighborhood", "Request neighborhoods, circles : 750 items (~6 days)", 950, 700],
                        // ["data/dudley-june23-750results-manuallycollated.json", "location/animation", "Request locations animated : 750 items (~6 days)", 950, 950],
                        ["data/dudley-june23-750results-manuallycollated.json", "location/map/circles", "Request neighborhoods, circles : 750 items (~6 days)", 950, 700],
                        ["data/dudley-june23-750results-manuallycollated.json", "location/map/choropleth", "Request neighborhoods, choropleth: 750 items (~6 days)", 950, 700],
                        // ["data/dudley-june23-750results-manuallycollated.json", "activity/hour/stacked", "Requests per hour, stacked : 750 items (~6 days)", 950, 400],                        
                        // ["data/dudley-june23-750results-manuallycollated.json", "activity/category", "Requests per category, pie : 750 items (~6 days)", 950, 500],
                        ["data/dudley-june23-750results-manuallycollated.json", "activity/neighborhood/stacked", "Requests per neighborhood, stacked : 750 items (~6 days)", 950, 400]
                      ];
    
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Init : Time series charts - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // this call starts everything.
    setup_charts();

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Functions - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    function buildNeighborhoodData(json_data, geojson){
      console.log("buildNeighborhoodData- ENTER");

      if (!counts){
        console.log("buildNeighborhoodData- performing counting");        

        counts = {};
        allRequestTypes = {};
        var parser = new OpenLayers.Format.GeoJSON();
        var vectors = parser.read(geojson);
        var lat, lon, point, neighborhood = "Unknown", category = "Uknown";
        json_data.forEach(function(row) {
            category = row.service_name;
            lat = row.lat;
            lon = row.long;
            point = new OpenLayers.Geometry.Point(lon, lat);
            
            //TODO: this loop is slightly inefficient, takes 6s to parse all the data...
            for( var i = 0; i < vectors.length; i++ ){
              var bounds = vectors[i].geometry.getBounds();
              var lonLat = new OpenLayers.LonLat(lon,lat);

              // Find the center point of the neighborhood.
              var center = bounds.getCenterLonLat();

              //console.log(bounds);
              if(bounds.containsLonLat(lonLat)){
                if(vectors[i].geometry.intersects(point)){
                //if(polygon.intersects(point)){
                   neighborhood = vectors[i].attributes['name'];
                   //console.log(neighborhood);
                   break;
                }
              }
            }

            // Store the neighborhood with its count (of how many times it was encountered until now).
            if (!counts[neighborhood]) {
                counts[neighborhood] = {numRequests: 0, centerPoint: {lon: center.lon, lat: center.lat}, categories: {} };
            }
            counts[neighborhood].numRequests++;
            // Store category count and add to category array.
            if (!counts[neighborhood].categories[category]) {
              counts[neighborhood].categories[category] = 0;
            }
            counts[neighborhood].categories[category]++;
            if (!allRequestTypes[category]) {
              allRequestTypes[category] = category;
            }
        });
      }
      
      console.log("buildNeighborhoodData- counts");
      console.log(counts);
      return counts;
    }

    // setup chart objects and data.
    function setup_charts() {
      
      for (var i = 0; i < charts_data.length; i++) {
        
        var _this = this;
        
        // Using a function/closure to localize "i" (and giving it another name, "this_i") so that "i" doesn't always end-up being the last index of the loop.
        (function(this_i){      //"localizing" i by using it in the inner function

          // Create the DOM chart element.
          $(".main_container").append("<div id='graph_container_"+ i +"' class='graph_container full_row'><h2>"+ charts_data[i][2] +"</h2><div id='graph_"+ i +"'></div></div>");

          // Set the chart's dimensions.
          var margin = {top: 30, right: 30, bottom: 30, left: 40};
          var width = charts_data[i][3] - margin.left - margin.right;
          var height = charts_data[i][4] - margin.top - margin.bottom;

          // Set the current chart var.
          var cur_chart = d3.select("#graph_" + i).append("svg")
              .attr("width", width + margin.left + margin.right)
              .attr("height", height + margin.top + margin.bottom)
              .attr("top", 100)
            .append("g")                                // "g" is a SVG group element for applying properties to many objects at once.
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");  
          charts[i] = cur_chart;
          // console.log(cur_chart);
  
          // Load the JSON data.
          d3.json(charts_data[this_i][0], function(error, json_data) {
            
            // console.log("- - - - - - - - - - - - - - - - - - #"+ this_i +" DATA : ")
            // console.log(json_data);

            // - - - - MAKE CHART: Map of Boston with 1 pulsing circle per neighborhood, based on activity.
            if (charts_data[this_i][1] == "location/map/circles"){
              
              d3.json("data/boston_neighborhoods.geojson", function(geojson) {
                // console.log("PRE-FORMAT geoJSON");
                // console.log(geojson);

                // 1) --- Custom-format our data into an array of objects as {neighborhood, numRequests}.

                // Build the array that counts the number of requests per neighborhood.
                var counts = buildNeighborhoodData(json_data, geojson);       // Create local version of the global counts var.

                // var counts = {};
                // var parser = new OpenLayers.Format.GeoJSON();
                // var vectors = parser.read(geojson);
                // var lat, lon, point, neighborhood = "Unknown";
                // json_data.forEach(function(row) {
                //     lat = row.lat;
                //     lon = row.long;
                //     point = new OpenLayers.Geometry.Point(lon, lat);
                    
                //     //TODO: this loop is slightly inefficient, takes 6s to parse all the data...
                //     for( var i = 0; i < vectors.length; i++ ){
                //       var bounds = vectors[i].geometry.getBounds();
                //       var lonLat = new OpenLayers.LonLat(lon,lat);

                //       // Find the center point of the neighborhood.
                //       var center = bounds.getCenterLonLat();

                //       //console.log(bounds);
                //         if(bounds.containsLonLat(lonLat)){
                //           if(vectors[i].geometry.intersects(point)){
                //           //if(polygon.intersects(point)){
                //              neighborhood = vectors[i].attributes['name'];
                //              //console.log(neighborhood);
                //              break;
                //           }
                //       }
                      
                //     }

                //     // Store the neighborhood with its count (of how many times it was encountered until now).
                //     if (!counts[neighborhood]) {
                //         counts[neighborhood] = {numRequests: 0, centerPoint: {lon: center.lon, lat: center.lat} };
                //     }
                //     counts[neighborhood].numRequests++;
                // });

                // console.log("NEIGHBORHOOD- counts");
                // console.log(counts);

                // Inject the number of requests per neighborhood into the geoJSON so it can be used when drawing the map.
                for (var i=0; i < geojson.features.length; i++){
                  var geojsonNeighborhood = geojson.features[i].properties.name;

                  for (var key in counts){
                    var dataNeighborhood = key;
                    var dataNumRequest = parseFloat(counts[key].numRequests);
                    var dataCenterPoint = counts[key].centerPoint;

                    if (geojsonNeighborhood == dataNeighborhood){
                      geojson.features[i].properties.num_requests = dataNumRequest;
                      geojson.features[i].properties.center = dataCenterPoint;
                      break;
                    } else {
                      geojson.features[i].properties.num_requests = 0;
                      geojson.features[i].properties.center = dataCenterPoint;
                    }
                  }
                }

                // console.log("POST-FORMAT geoJSON");
                // console.log(geojson);


                // 2) --- Create the map.

                var projection = d3.geo.mercator()
                 .translate([width/2, height/2])
                 .scale([150000])
                 .center([-71.07, 42.32]);

                var bostonPath = d3.geo.path()
                  .projection(projection);

                var color = d3.scale.linear()
                    .range(["#f7fbff", "rgb(31, 119, 180)"])        // I chose colors from ColorBrewer.
                    .domain([
                      d3.min(geojson.features, function(d) { return d.properties.num_requests; }),
                      d3.max(geojson.features, function(d) { return d.properties.num_requests; })
                    ])
                    .nice();                              // will change the range from [1, 121] to [1, 130] to get nice whole numbers.

                var strokeColor = "#ccc";

                charts[this_i].selectAll("path")
                  .data(geojson.features)
                  .enter()
                  .append("path")
                  .attr("class", "boston_map")
                  .attr("d", bostonPath)
                  .attr("neighborhood", function(d){
                    return d.properties.name;
                  })
                  .attr("num_requests", function(d){
                    return d.properties.num_requests;
                  })
                  .style("fill", "#fff")
                  .style("stroke", strokeColor);
                
                var numRequestsScaling = d3.scale.linear()
                  .range([1, 40])
                  .domain([
                      d3.min(geojson.features, function(d) { return d.properties.num_requests; }),
                      d3.max(geojson.features, function(d) { return d.properties.num_requests; })
                    ]);
                charts[this_i].selectAll("circle")
                  .data(geojson.features)
                  .enter()
                  .append("circle")
                  .attr("cx", function(d){
                    return projection([d.properties.center.lon, d.properties.center.lat])[0];
                  })
                  .attr("cy", function(d){
                    return projection([d.properties.center.lon, d.properties.center.lat])[1];
                  })
                  .attr("r", function(d){
                    return numRequestsScaling(d.properties.num_requests);
                  })
                  .style("fill", "red")
                  .style("stroke", "white")
                  .style("opacity", 0.5);

              });
            }
            // - - - - MAKE CHART: Request per neighborhood, bar chart.
            else if (charts_data[this_i][1] == "activity/neighborhood"){

              // Import GEOjson data of Boston neighborhoods.
              d3.json("data/boston_neighborhoods.geojson", function(error, geojson) {

                // 1) --- Custom-format our data into an array of objects as {neighborhood, numRequests}.

                // Build the array that counts the number of requests per neighborhood.
                // Build the array that counts the number of requests per neighborhood.
                var counts = buildNeighborhoodData(json_data, geojson);       // Create local version of the global counts var.

                // var counts = {};
                // var parser = new OpenLayers.Format.GeoJSON();
                // var vectors = parser.read(geojson);
                // var lat, lon, point, neighborhood = "Unknown";
                // json_data.forEach(function(row) {
                //     lat = row.lat;
                //     lon = row.long;
                //     point = new OpenLayers.Geometry.Point(lon, lat);
                    
                //     //TODO: this loop is slightly inefficient, takes 6s to parse all the data...
                //     for( var i = 0; i < vectors.length; i++ ){
                //       var bounds = vectors[i].geometry.getBounds();
                //       var lonLat = new OpenLayers.LonLat(lon,lat);
                //       //console.log(bounds);
                //         if(bounds.containsLonLat(lonLat)){
                //           if(vectors[i].geometry.intersects(point)){
                //              neighborhood = vectors[i].attributes['name'];
                //              //console.log(neighborhood);
                //              break;
                //           }
                //       }
                      
                //     }

                //     // Store the neighborhood with its count (of how many times it was encountered until now).
                //     if (!counts[neighborhood]) {
                //         counts[neighborhood] = 0;
                //     }
                //     counts[neighborhood]++;
                // });

                // console.log("NEIGHBORHOOD- counts");
                // console.log(counts);

                // Use the counts array to build a proper array of data objects {neighborhood, count}.
                var data = [];
                


                for (var key in counts){
                  var dataNeighborhood = key;
                  var dataNumRequest = parseFloat(counts[key].numRequests);
                  data.push({
                    neighborhood: dataNeighborhood,
                    numRequests: dataNumRequest
                  });
                }



                // Loop thru each key in counts, and push the key as item #1 and the counts as item #2.
                // Object.keys(counts).forEach(function(key) {
                //     data.push({
                //         neighborhood: key,
                //         numRequests: counts[key]
                //     });
                // });

                // console.log("NEIGHBORHOOD- data PRE-SORT: ");
                // console.log(data);

                // A comparison function that is used to sort the dates in ascending order (oldest to newest).
                var date_sort_asc = function (neighborhood1, neighborhood2) {
                  if (neighborhood1.neighborhood > neighborhood2.neighborhood) return 1;
                  if (neighborhood1.neighborhood < neighborhood2.neighborhood) return -1;
                  return 0;
                };
                
                // Sort the dates (because d3.extent() in domain() below expects items to be sorted).
                data.sort(date_sort_asc);

                // Copy new data back into json_data for convenience (so all charts use json_data for building their chart).
                json_data = data.slice();
                
                // console.log("NEIGHBORHOOD- json_data POST-SORT: ");
                // console.log(json_data);


                // 2) --- Now we can create the chart.
                
                height -= 100;      // Reduce the height of the graph to fit the graph + labels into the div.

                var x = d3.scale.ordinal()
                  .rangeRoundBands([0, width], .1)
                  .domain(json_data.map(function(d) { return d.neighborhood; }));

                var y = d3.scale.linear()
                    .range([height, 0])
                    .domain([0, d3.max(json_data, function(d) { return d.numRequests; })]);

                var xAxis = d3.svg.axis()
                    .scale(x)
                    .orient("bottom");

                var yAxis = d3.svg.axis()
                    .scale(y)
                    .orient("left");

                charts[this_i].append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + height + ")")
                    .call(xAxis)
                  .selectAll("text")
                      .attr("y", 0)
                      .attr("x", 9)
                      .attr("dy", ".35em")
                      .attr("transform", "rotate(90)")
                      .style("text-anchor", "start");

                charts[this_i].append("g")
                    .attr("class", "y axis")
                    .call(yAxis)
                  .append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 6)
                    .attr("dy", ".71em")
                    .style("text-anchor", "end")
                    .text("#Requests");

                charts[this_i].selectAll(".bar")
                    .data(json_data)
                  .enter().append("rect")
                    .attr("class", "bar")
                    .attr("x", function(d) { return x(d.neighborhood); })
                    .attr("width", x.rangeBand())
                    .attr("y", function(d) { return y(d.numRequests); })
                    .attr("height", function(d) { return height - y(d.numRequests); });

              });
              
            }

            // - - - - MAKE CHART: Request per neighborhood, category stacked bar chart.
            else if (charts_data[this_i][1] == "activity/neighborhood/stacked"){

              // Import GEOjson data of Boston neighborhoods.
              d3.json("data/boston_neighborhoods.geojson", function(error, geojson) {

                // 1) --- Custom-format our data into an array of objects as {neighborhood, numRequests}.

                // Build the array that counts the number of requests per neighborhood.
                var counts = buildNeighborhoodData(json_data, geojson);       // Create local version of the global counts var.

                // var counts = {};
                // var allRequestTypes = {};
                // var parser = new OpenLayers.Format.GeoJSON();
                // var vectors = parser.read(geojson);
                // var lat, lon, point, neighborhood, category = "Unknown";
                // json_data.forEach(function(row) {
                //     category = row.service_name;
                //     lat = row.lat;
                //     lon = row.long;
                //     point = new OpenLayers.Geometry.Point(lon, lat);
                    
                //     //Loop to determine location.
                //     for( var i = 0; i < vectors.length; i++ ){
                //       var bounds = vectors[i].geometry.getBounds();
                //       var lonLat = new OpenLayers.LonLat(lon,lat);
                      
                //       if(bounds.containsLonLat(lonLat)){
                        
                //         if(vectors[i].geometry.intersects(point)){
                //            neighborhood = vectors[i].attributes['name'];
                //            break;
                //         }
                //       }
                //     }

                //     // Store the neighborhood with its count (of how many times it was encountered until now).
                //     // Store category count and add to category array.
                //     if (!counts[neighborhood]) {
                //         counts[neighborhood] = {"total":0, "categories": {}};
                //     }
                //     counts[neighborhood].total++;
                //     if (!counts[neighborhood].categories[category]) {
                //       counts[neighborhood].categories[category] = 0;
                //     }
                //     counts[neighborhood].categories[category]++;
                //     if (!allRequestTypes[category]) {
                //       allRequestTypes[category] = category;
                //     } 
                // });

                console.log("NEIGHBORHOOD- counts");
                console.log(counts);

                // Use the counts array to build a proper array of data objects {neighborhood, count}.
                var data = [];
                // Loop thru each key in counts, and push the key as item #1 and the counts as item #2, and categories as item #3.
                Object.keys(counts).forEach(function(key) {
                    data.push({
                        neighborhood: key,
                        numRequests: counts[key].numRequests,
                        categories: counts[key].categories
                    });
                });

                var allReq = [];
                Object.keys(_this.allRequestTypes).forEach(function(key) {
                      allReq.push(key);
                });

                // A comparison funciton that is used to sort the dates in ascending order (oldest to newest).
                var date_sort_asc = function (neighborhood1, neighborhood2) {
                  if (neighborhood1.neighborhood > neighborhood2.neighborhood) return 1;
                  if (neighborhood1.neighborhood < neighborhood2.neighborhood) return -1;
                  return 0;
                };
                
                // Sort the dates (because d3.extent() in domain() below expects items to be sorted).
                data.sort(date_sort_asc);
                console.log("* * * * *")
                console.log(data);

                // Copy new data back into json_data for convenience (so all charts use json_data for building their chart).
                json_data = data.slice();

                // Create the d3 Stack Layout by mapping the data.
                var allCat = d3.layout.stack()(allReq.map(function(req) {
                  return json_data.map(function(d) {
                    if (d.categories[req]) {
                      return {name: req, x: d.neighborhood, y: d.categories[req]};
                    } else {
                      return {name: req, x: d.neighborhood, y: 0};
                    }
                  });
                }));


                // 2) --- Now we can create the chart.
                
                height -= 100;      // Reduce the height of the graph to fit the graph + labels into the div.

                var color = d3.scale.category20();

                var x = d3.scale.ordinal()
                  .rangeRoundBands([0, width], .1)
                  .domain(json_data.map(function(d) { return d.neighborhood; }));

                var y = d3.scale.linear()
                    .range([height, 0])
                    .domain([0, d3.max(allCat[allCat.length - 1], function(d) { return d.y0 + d.y; })]);

                var xAxis = d3.svg.axis()
                    .scale(x)
                    .orient("bottom");

                var yAxis = d3.svg.axis()
                    .scale(y)
                    .orient("left");

                charts[this_i].append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + height + ")")
                    .call(xAxis)
                  .selectAll("text")
                      .attr("y", 0)
                      .attr("x", 9)
                      .attr("dy", ".35em")
                      .attr("transform", "rotate(90)")
                      .style("text-anchor", "start");

                charts[this_i].append("g")
                    .attr("class", "y axis")
                    .call(yAxis)
                  .append("text")
                    .attr("transform", "rotate(-90)")
                    .attr("y", 6)
                    .attr("dy", ".71em")
                    .style("text-anchor", "end")
                    .text("#Requests");

                var catRequests = charts[this_i].selectAll(".request")
                    .data(allCat)
                  .enter().append("g")
                    .attr("class", "request")
                    .style("fill", function(d, i) { return color(d[0].name); });
                    //.style("stroke", function(d, i) { return d3.rgb(color(d[0].name)).darker(); });

                catRequests.selectAll(".bar2")
                    .data(function(d) {return d})
                  .enter().append("rect")
                    .attr("class", "bar2")
                    .attr("x", function(d) { return x(d.x); })
                    .attr("width", x.rangeBand())
                    .attr("y", function(d) { return  y(d.y0+d.y); })
                    .attr("height", function(d) { return height - y(d.y); });


                //Ledgend copied from JC's work. "d" has been manipulated for current data set.
                var legend = charts[this_i].selectAll(".legend")
                      .data(allCat)
                    .enter().append("g")
                      .attr("class", "legend")
                      .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

                legend.append("rect")
                    .attr("x", width)
                    .attr("width", 18)
                    .attr("height", 18)
                    .style("fill", function(d) { return color(d[0].name); });

                legend.append("text")
                    .attr("x", width - 5)
                    .attr("y", 9)
                    .attr("dy", ".35em")
                    .style("text-anchor", "end")
                    .text(function(d) { return d[0].name; });

              });
              
            }
            // - - - - MAKE CHART: Request Category, pie chart.
            else if (charts_data[this_i][1] == "activity/category"){
              
              //---"counts" array used to create Data array "catData"---
              var counts = [];
              var catData = [];

              //---Build Arrays step 1---
              json_data.forEach(function(row) {
                
                var category = row.service_name;

                if (!counts[category]) {
                  counts[category] = 0
                  catData.push({"name": category, "count": 0});
                };

                counts[category]++;

              });

              //---Build Arrays step 2---
              catData.forEach(function(value) {
                value.count = counts[value.name];
              });

              //---Create Pie Chart---
              var radius = height - 210,
                  labelr = radius + 10, // Label distance from center.
                  posX = width/2,
                  posY = height/2;

              var color = d3.scale.category20();

              //Arc Slice Template Element
              var arc = d3.svg.arc()
                .outerRadius(radius)
                .innerRadius(0);

              //Pie Charts use a layout in D3  
              var pie = d3.layout.pie()
                  .sort(null)
                  .value(function(d) { return d.count; });

              //Pass in Data and position new group.
              var g = cur_chart.selectAll(".arc")
                  .data(pie(catData))
                .enter().append("g")
                  .attr("transform", "translate(" + posX + "," + posY + ")")
                  .attr("class", "arc");

              g.append("path")
                .attr("d", arc)
                .style("fill", function(d) { return color(d.data.name); });

              //--Labels--
              g.append("text")
                .attr("transform", function(d) {
                    //--Math for Labels--
                    var c = arc.centroid(d),
                        x = c[0],
                        y = c[1],
                        // pythagorean theorem for hypotenuse
                        h = Math.sqrt(x*x + y*y);
                    return "translate(" + (x/h * labelr) +  ',' +
                       (y/h * labelr) +  ")"; 
                })
                .attr("dy", ".35em")
                .style("text-anchor", function(d) {
                    // are we past the center?
                    return (d.endAngle + d.startAngle)/2 > Math.PI ?
                        "end" : "start";
                })
                .text(function(d) {
                  //Math for percentage with 1 decimal point. 
                  return Math.round(((d.endAngle - d.startAngle)/(2*Math.PI))*1000)/10 + "%";
                });

              //Ledgend copied from JC's work. "d" has been manipulated for current data set.
              var legend = charts[this_i].selectAll(".legend")
                    .data(catData)
                  .enter().append("g")
                    .attr("class", "legend")
                    .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

              legend.append("rect")
                  .attr("x", width - 18)
                  .attr("width", 18)
                  .attr("height", 18)
                  .style("fill", function(d) { return color(d.name); });

              legend.append("text")
                  .attr("x", width - 24)
                  .attr("y", 9)
                  .attr("dy", ".35em")
                  .style("text-anchor", "end")
                  .text(function(d) { return d.name; });

            }
            // - - - - MAKE CHART: Request per hour, bar chart.
            else if (charts_data[this_i][1] == "activity/hour"){
              
              // 1) --- Custom-format our data into an array of objects as {hour, numOfRequestsThatHour}.

              var parseDate = d3.time.format("%Y-%m-%dT%H%Z").parse;

              // Build the array that counts requests per hour.
              var counts = {};
              json_data.forEach(function(row) {
                  // Format the date to represent a hour.
                  var date = row.updated_datetime.slice(0, -3) + row.updated_datetime.slice(-2);     // remove the colon ':' from the timezone at the end.
                  date = date.slice(0, 13) + date.slice(-5);     // remove anything smaller than a hour (ie. remove seconds).
                  date = parseDate(date);                                  //TODO: timezone isn't working correctly....
                  
                  // Store the date with its count (of how many times it was encountered until now).
                  if (!counts[date]) {
                      counts[date] = 0;
                  }
                  counts[date]++;
              });
              // Use the counts array to build a proper array of data objects {hour, count}.
              var data = [];
              // Loop thru each key in counts, and push the key as item #1 and the counts as item #2.
              Object.keys(counts).forEach(function(key) {
                  // The 'key' in counts is the date. We must convert it back to a Date obj because this loop casts it to a string (weirdly).
                  key = new Date(key);
                  data.push({
                      updated_datetime: key,
                      requests: counts[key]
                  });
              });
              
              // console.log("counts: ");
              // console.log(counts);
              // console.log("data PRE-SORT: ");
              // console.log(data);

              // A comparison funciton that is used to sort the dates in ascending order (oldest to newest).
              var date_sort_asc = function (date1, date2) {
                if (date1.updated_datetime > date2.updated_datetime) return 1;
                if (date1.updated_datetime < date2.updated_datetime) return -1;
                return 0;
              };
              
              // Sort the dates (because d3.extent() in domain() below expects items to be sorted).
              data.sort(date_sort_asc);

              // Copy new data back into json_data for convenience (so all charts use json_data for building their chart).
              json_data = data.slice();
              
              // console.log("json_data POST-SORT: ");
              // console.log(json_data);

              // 2) --- Now we can create the chart.
              
              var x = d3.time.scale()
                .range([0, width])
                .domain(d3.extent(json_data, function(d) { return d.updated_datetime; }));

              var y = d3.scale.linear()
                  .range([height, 0])
                  .domain([0, d3.max(json_data, function(d) { return d.requests; })]);

              var xAxis = d3.svg.axis()
                  .scale(x)
                  .orient("bottom");

              var yAxis = d3.svg.axis()
                  .scale(y)
                  .orient("left");

              charts[this_i].append("g")
                  .attr("class", "x axis")
                  .attr("transform", "translate(0," + height + ")")
                  .call(xAxis)
                .append("text")
                  .attr("class", "label")
                  .attr("x", width)
                  .attr("y", -6)
                  .style("text-anchor", "end")
                  .text("Hour");

              charts[this_i].append("g")
                  .attr("class", "y axis")
                  .call(yAxis)
                .append("text")
                  .attr("transform", "rotate(-90)")
                  .attr("y", 6)
                  .attr("dy", ".71em")
                  .style("text-anchor", "end")
                  .text("#Requests");

              charts[this_i].selectAll(".bar")
                  .data(json_data)
                .enter().append("rect")
                  .attr("class", "bar")
                  .attr("x", function(d) { return x(d.updated_datetime); })
                  .attr("width", 2)
                  .attr("y", function(d) { return y(d.requests); })
                  .attr("height", function(d) { return height - y(d.requests); });

            }
            // - - - - MAKE CHART: Location Long/Lat, scatterplot.
            else if (charts_data[this_i][1] == "location/animation"){
              
              var x = d3.scale.linear()
                .range([0, width])
                .domain(d3.extent(json_data, function(d) { return d.lat; })).nice();

              var y = d3.scale.linear()
                .range([height, 0])
                .domain(d3.extent(json_data, function(d) { return d.long; })).nice();

              var xAxis = d3.svg.axis()
                  .scale(x)
                  .orient("bottom");

              var yAxis = d3.svg.axis()
                  .scale(y)
                  .orient("left");

              var color = d3.scale.category20();    // Creates 20 colors to color the dots.

              json_data.forEach(function(d) {
                d.lat = +d.lat;
                d.long = +d.long;
              });

              charts[this_i].append("g")
                  .attr("class", "x axis")
                  .attr("transform", "translate(0," + height + ")")
                  .call(xAxis)
                .append("text")
                  .attr("class", "label")
                  .attr("x", width)
                  .attr("y", -6)
                  .style("text-anchor", "end")
                  .text("Latitude");

              charts[this_i].append("g")
                  .attr("class", "y axis")
                  .call(yAxis)
                .append("text")
                  .attr("class", "label")
                  .attr("transform", "rotate(-90)")
                  .attr("y", 6)
                  .attr("dy", ".71em")
                  .style("text-anchor", "end")
                  .text("Longitude");

              charts[this_i].selectAll(".dot")
                .data(json_data)
              .enter().append("circle")
                .attr("class", "dot")
                .attr("r", 0)
                .attr("cx", function(d) { return x(d.lat); })
                .attr("cy", function(d) { return y(d.long); })
                .style("opacity",0)
                .style("fill", function(d) { return color(d.service_name); })
              .transition()
                .delay(function(d, i){ return i*50})
                .duration(2000)
                .attr("r", 35)
                .style("opacity",0.7)
                .transition()
                  .attr("r", 3.5)
                  .style("opacity",1);

              var legend = charts[this_i].selectAll(".legend")
                    .data(color.domain())
                  .enter().append("g")
                    .attr("class", "legend")
                    .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

              legend.append("rect")
                  .attr("x", width - 18)
                  .attr("width", 18)
                  .attr("height", 18)
                  .style("fill", color);

              legend.append("text")
                  .attr("x", width - 24)
                  .attr("y", 9)
                  .attr("dy", ".35em")
                  .style("text-anchor", "end")
                  .text(function(d) { return d; });

            }
            // - - - - MAKE CHART: Choropleth map of Boston.
            else if (charts_data[this_i][1] == "location/map/choropleth"){
              
              d3.json("data/boston_neighborhoods.geojson", function(geojson) {
                // console.log("PRE-FORMAT geoJSON");
                // console.log(geojson);

                // 1) --- Custom-format our data into an array of objects as {neighborhood, numRequests}.

                // Build the array that counts the number of requests per neighborhood.
                var counts = buildNeighborhoodData(json_data, geojson);       // Create local version of the global counts var.

                // var counts = {};
                // var parser = new OpenLayers.Format.GeoJSON();
                // var vectors = parser.read(geojson);
                // var lat, lon, point, neighborhood = "Unknown";
                // json_data.forEach(function(row) {
                //     lat = row.lat;
                //     lon = row.long;
                //     point = new OpenLayers.Geometry.Point(lon, lat);
                    
                //     // DEV-JUSTIN:
                //     //var multiPolygon = new OpenLayers.Geometry.Collection(vectors[i].geometry);
                //     //var polygon = new OpenLayers.Geometry.Polygon(multiPolygon.components[0]);
                //     //console.log("-- - -  ---- - - - - - -");
                //     //console.log(multiPolygon);
                //     //var polygon = multiPolygon;

                //     //TODO: this loop is slightly inefficient, takes 6s to parse all the data...
                //     for( var i = 0; i < vectors.length; i++ ){
                //       var bounds = vectors[i].geometry.getBounds();
                //       var lonLat = new OpenLayers.LonLat(lon,lat);
                //       //console.log(bounds);
                //         if(bounds.containsLonLat(lonLat)){
                //           if(vectors[i].geometry.intersects(point)){
                //           //if(polygon.intersects(point)){
                //              neighborhood = vectors[i].attributes['name'];
                //              //console.log(neighborhood);
                //              break;
                //           }
                //       }
                      
                //     }

                //     // Store the neighborhood with its count (of how many times it was encountered until now).
                //     if (!counts[neighborhood]) {
                //         counts[neighborhood] = {numRequests: 0};
                //     }
                //     counts[neighborhood].numRequests++;
                // });

                // console.log("NEIGHBORHOOD- counts");
                // console.log(counts);


                // Inject the number of requests per neighborhood into the geoJSON so it can be used when drawing the map.
                for (var i=0; i < geojson.features.length; i++){
                  var geojsonNeighborhood = geojson.features[i].properties.name;

                  for (var key in counts){
                    var dataNeighborhood = key;
                    var dataNumRequest = parseFloat(counts[key].numRequests);

                    if (geojsonNeighborhood == dataNeighborhood){
                      geojson.features[i].properties.num_requests = dataNumRequest;
                      break;
                    } else {
                      geojson.features[i].properties.num_requests = 0;
                    }
                  }
                }

                // console.log("POST-FORMAT geoJSON");
                // console.log(geojson);


                // 2) --- Create the choropleth map.

                var projection = d3.geo.mercator()
                 .translate([width/2, height/2])
                 .scale([150000])
                 .center([-71.07, 42.32]);

                var bostonPath = d3.geo.path()
                  .projection(projection);

                var color = d3.scale.linear()
                    .range(["#f7fbff", "rgb(31, 119, 180)"])        // I chose colors from ColorBrewer.
                    .domain([
                      d3.min(geojson.features, function(d) { return d.properties.num_requests; }),
                      d3.max(geojson.features, function(d) { return d.properties.num_requests; })
                    ])
                    .nice();                              // will change the range from [1, 121] to [1, 130] to get nice whole numbers.

                var strokeColor = "#D8D8D8";

                charts[this_i].selectAll("path")
                  .data(geojson.features)
                  .enter()
                  .append("path")
                  .attr("class", "boston_map")
                  .attr("d", bostonPath)
                  .attr("neighborhood", function(d){
                    return d.properties.name;
                  })
                  .attr("num_requests", function(d){
                    return d.properties.num_requests;
                  })
                  .style("fill", function(d){
                    var num_requests = d.properties.num_requests;
                    if(num_requests > 0){
                      return color(num_requests);
                    } else {
                      return "#fff";    // if the neighborhood doesn't have any num_requests, then give it a pure white color fill.
                    }
                  })
                  .style("stroke", function(d){
                    var num_requests = d.properties.num_requests;
                    if(num_requests == 0){
                      return strokeColor;    // if the neighborhood doesn't have any num_requests, then give it a slight gray stroke.
                    }
                  });

                  var legendWidth = 18 * 4;
                  var legend = charts[this_i].selectAll(".legend")
                    .data(color.domain())
                  .enter().append("g")
                    .attr("class", "legend")
                    .attr("transform", function(d, i) { return "translate(0, 0)"; });

                  var gradient = legend.append("svg:defs")
                    .append("svg:linearGradient")
                      .attr("id", "gradient")
                      .attr("x1", "0%")
                      .attr("y1", "0%")
                      .attr("x2", "100%")
                      .attr("y2", "0%")
                      .attr("spreadMethod", "pad");

                  gradient.append("svg:stop")
                      .attr("offset", "0%")
                      .attr("stop-color", color.range()[0])
                      .attr("stop-opacity", 1);

                  gradient.append("svg:stop")
                      .attr("offset", "100%")
                      .attr("stop-color", color.range()[1])
                      .attr("stop-opacity", 1);

                  charts[this_i].append("svg:rect")
                      .attr("x", width - legendWidth)
                      .attr("y", 10)
                      .attr("width", legendWidth)
                      .attr("height", 18)
                      .style("fill", "url(#gradient)")
                      .style("stroke", strokeColor);

                  // Add text for max of range.
                  legend.append("text")
                      .attr("x", width)
                      .attr("y", 40)
                      .attr("dy", ".35em")
                      .style("text-anchor", "end")
                      .text(function(d) { return d; });
                  // Add text for min of range.
                  legend.append("text")
                      .attr("x", width - legendWidth + 5)
                      .attr("y", 40)
                      .attr("dy", ".35em")
                      .style("text-anchor", "end")
                      .text("0");
                  // Add legend title.
                  legend.append("text")
                      .attr("x", width - 25)
                      .attr("y", 0)
                      .attr("dy", ".35em")
                      .style("text-anchor", "end")
                      .text("#Requests");

              });
            }
            // - - - - MAKE STACKED CHART: Request per hour, open vs closed bar chart.
            else if (charts_data[this_i][1] == "activity/hour/stacked"){

              // 1) --- Custom-format our data into an array of objects as {hour, numOfRequestsThatHour}.

              var parseDate = d3.time.format("%Y-%m-%dT%H%Z").parse;

              // Build the array that counts requests per hour.
              var counts = {};
              json_data.forEach(function(row) {
                  // Format the date to represent a hour.
                  var date = row.updated_datetime.slice(0, -3) + row.updated_datetime.slice(-2);     // remove the colon ':' from the timezone at the end.
                  date = date.slice(0, 13) + date.slice(-5);     // remove anything smaller than a hour (ie. remove seconds).
                  date = parseDate(date);                        //TODO: timezone isn't working correctly....
                  

                  // Store the date with its count (of how many times it was encountered until now).
                  if (!counts[date]) {
                      counts[date] = {"count": 0, "opened": 0, "closed": 0};
                  };
                  counts[date].count++;

                  if (row.status == "open") {
                    counts[date].opened++;
                  } else {
                    counts[date].closed++;
                  }

              });
              // Use the counts array to build a proper array of data objects {hour, count}.
              var data = [];
              // Loop thru each key in counts, and push the key as item #1 and the counts as item #2.
              Object.keys(counts).forEach(function(key) {
                  // The 'key' in counts is the date. We must convert it back to a Date obj because this loop casts it to a string (weirdly).
                  key = new Date(key);
                  data.push({
                      updated_datetime: key,
                      requests: counts[key].count,
                      opened: counts[key].opened,
                      closed: counts[key].closed
                  });
              });
              
              // A comparison funciton that is used to sort the dates in ascending order (oldest to newest).
              var date_sort_asc = function (date1, date2) {
                if (date1.updated_datetime > date2.updated_datetime) return 1;
                if (date1.updated_datetime < date2.updated_datetime) return -1;
                return 0;
              };
              
              // Sort the dates (because d3.extent() in domain() below expects items to be sorted).
              data.sort(date_sort_asc);

              // Copy new data back into json_data for convenience (so all charts use json_data for building their chart).
              json_data = data.slice();

              //Converting the data into a d3 stack layout object. In this case we are going through looking for opened and closed.
              var openClose = d3.layout.stack()(["opened", "closed"].map(function(req) {
                return json_data.map(function(d) {
                  return {name: req, x: d.updated_datetime, y: d[req]};
                });
              }));
              console.log("--OPEN CLOSE--");
              console.log(openClose);
              // 2) --- Now we can create the chart.
              
              //As we have different data categories the are assign the following colors.
              var color = d3.scale.category20();

              var x = d3.time.scale()
                .range([0, width-5]);

              var y = d3.scale.linear()
                  .range([height, 0]);


              //
              var barChart = cur_chart.append("svg:svg")
                  .attr("width", width)
                  .attr("height", height)
                .append("svg:g")
                  .attr("transform", "translate(" + 1 + "," + height + ")");

              // Compute the x-domain (by date) and y-domain (by top).
              x.domain(d3.extent(json_data, function(d) { return d.updated_datetime; }));
              y.domain([0, d3.max(openClose[openClose.length - 1], function(d) { return d.y0 + d.y; })]);


              var xAxis = d3.svg.axis()
                  .scale(x)
                  .orient("bottom");

              var yAxis = d3.svg.axis()
                  .scale(y)
                  .orient("left");

              charts[this_i].append("g")
                  .attr("class", "x axis")
                  .attr("transform", "translate(0," + height + ")")
                  .call(xAxis)
                .append("text")
                  .attr("class", "label")
                  .attr("x", width)
                  .attr("y", 20)
                  .style("text-anchor", "end")
                  .text("Hour");

              charts[this_i].append("g")
                  .attr("class", "y axis")
                  .call(yAxis)
                .append("text")
                  .attr("transform", "rotate(-90)")
                  .attr("y", 6)
                  .attr("dy", ".71em")
                  .style("text-anchor", "end")
                  .text("#Requests");

              var request = barChart.selectAll("g.request")
                  .data(openClose)
                .enter().append("g")
                  .attr("class", "request")
                  .style("fill", function(d, i) { return color(i); })
                  .style("stroke", function(d, i) { return d3.rgb(color(i)).darker(); });

              // Add a rect for each date.
              var rect = request.selectAll("rect")
                  .data(function(d) { return d; })
                .enter().append("rect")
                  .attr("x", function(d) { return x(d.x); })
                  .attr("y", function(d) { return  -height + y(d.y0+d.y); }) //We are inverted ---^---
                  .attr("height", function(d) { return height - y(d.y); })
                  .attr("width", 4);

              var legend = charts[this_i].selectAll(".legend")
                    .data(openClose)
                  .enter().append("g")
                    .attr("class", "legend")
                    .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

              legend.append("rect")
                  .attr("x", width - 18)
                  .attr("width", 18)
                  .attr("height", 18)
                  .style("fill", function(d, i) { return color(i); });

              legend.append("text")
                  .attr("x", width - 24)
                  .attr("y", 9)
                  .attr("dy", ".35em")
                  .style("text-anchor", "end")
                  .text(function(d, i) { return d[0].name; });

            }

          });
          
        }(i));    //pass in our "i" from the loop
      }

    }
    
  </script>
  
  </body>
</html>